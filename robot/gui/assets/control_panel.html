<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Панель управления</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.0/css/bulma.min.css">

    <style>
        img {
            max-width: 40%;
            border: 2px solid #444;
            margin-bottom: 20px;
        }

        svg {
            width: 100%;
            height: auto;
        }
    </style>

    <script src="/static/js/ws_video_stream.js"></script>
    <script src="/static/js/gui_channel.js"></script>

</head>
<body>
<p class="subtitle is-4 has-text-centered mt-3 mb-0">Панель управления</p>
<section class="section is-fullwidth container is-fluid">
    <div class="box">
        <p class="subtitle is-4 has-text-centered">Потоки</p>
        <div id="streams-tabs" class="tabs">
            <ul>

            </ul>
        </div>
        <img id="stream-image">
    </div>
    <div class="box">
        <p class="subtitle is-4 has-text-centered">Навигация</p>
        
        <svg id="chartRoot" preserveAspectRatio="xMidYMid meet"></svg>
    </div>
</section>

<script>
    CHANNEL_PATH = "/control_panel";

    const streams = {};
    var activeStream = null;

    window.addEventListener("channel_ready", function (event) {

        event.detail.channel.addEventListener("code_stream", function(event) {
            addStream(event.detail.id, event.detail.url, event.detail.name);
        });

         event.detail.channel.addEventListener("code_set_robot_pos", function(event) {
             setRobotPos(event.detail.x, event.detail.y);
        });

         event.detail.channel.addEventListener("code_chart", function(event) {
             console.log("Received chart", event.detail.points)
             drawChart(event.detail.zones, event.detail.points);
        });

    });

    function addStream(id, url, name) {
        console.log(`Adding stream ${name} (${url})`);
        var imageElement = document.getElementById("stream-image");
        streams[id] = {"id": id, "url": url, "name": name, "stream": new WSVideoStream(url, imageElement)};
        var tabs = document.getElementById("streams-tabs");
        var tabsList = tabs.getElementsByTagName("ul")[0];
        tabsList.insertAdjacentHTML("beforeend", `<li id="stream-button-${id}"><a onclick="onStreamClicked('${id}')">${name}</a></li>`);
    }

    function onStreamClicked(id) {
        if (activeStream?.id == id) {
            stopActiveStream();
        }
        else {
            setActiveStream(id);
        }
    }

    function setActiveStream(id) {
        if (activeStream) {
            stopActiveStream();
        }

        var stream = streams[id];
        if (!stream) {
            console.log(`Unknown stream ${id}`);
            return;
        }

        activeStream = stream;
        document.getElementById(`stream-button-${id}`).classList.add("is-active");
        activeStream.stream.begin();
    }

    function stopActiveStream() {
        if (!activeStream) {
            return;
        }

        activeStream.stream.stop();
        var tabsList = document.getElementById("streams-tabs").getElementsByTagName("ul")[0];
        tabsList.childNodes.forEach((el) => {
            el.classList?.remove("is-active");
        });
        activeStream = null;
    }

    // Получаем элемент SVG
    const svg = document.getElementById('chartRoot');

    // Функция для создания элементов SVG
    function createSVGElement(tag, attrs) {
        const elem = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (let attr in attrs) {
            elem.setAttribute(attr, attrs[attr]);
        }
        return elem;
    }

    // Функция для настройки viewBox (масштабирование и смещение начала координат)
    function setViewBox(x, y, width, height) {
        svg.setAttribute('viewBox', `${x} ${y} ${width} ${height}`);
    }

    const MAP_WIDTH = 900;
    const MAP_HEIGHT = 260;

    const MAP_PADDING = 10;

    const GRAY_MAIN = "#757575";
    const GRAY_SUB = "#303030";

    const RED = "#FF5050";

    setViewBox(0, 0, MAP_WIDTH + MAP_PADDING * 2, MAP_HEIGHT + MAP_PADDING * 2);

    function drawBorder() {
        const border = createSVGElement("rect", {
            id: "border",
            x: MAP_PADDING,
            y: MAP_PADDING,
            width: MAP_WIDTH,
            height: MAP_HEIGHT,
            rx: 6,
            opacity: "undefined",
            stroke: GRAY_MAIN,
            "fill-opacity": "0", 
        });
        svg.appendChild(border);
    }

    drawBorder();

    const ZERO_X = 150;
    const ZERO_Y = MAP_HEIGHT / 2;
    console.log(ZERO_Y);

    function toSVGPos(x, y) {
        return [ZERO_X + x + MAP_PADDING, ZERO_Y - y + MAP_PADDING];
    }

    function drawZero() {
        var [svg_x, svg_y] = toSVGPos(0, 0);
        
        const zeroGroup = createSVGElement("g", {
            id: "zero",
            "fill-opacity": 0,
            "stroke-width": 1,
            stroke: GRAY_SUB,
        });

        const zeroVert = createSVGElement("line", {
            id: "zero_vert",
            x1: svg_x,
            y1: svg_y - 15,
            x2: svg_x,
            y2: svg_y + 15,
        })
        zeroGroup.append(zeroVert);

        const zeroHoriz = createSVGElement("line", {
            id: "zero_horiz",
            x1: svg_x - 15,
            y1: svg_y,
            x2: svg_x + 15,
            y2: svg_y,
        })
        zeroGroup.append(zeroHoriz);

        svg.append(zeroGroup);
    }

    drawZero();

    const ROBOT_WIDTH = 88;
    const ROBOT_HEIGHT = 26;

    function addRobot(x, y) {
        const [svg_x, svg_y] = toSVGPos(x, y);

        const robot = createSVGElement("svg", {
            id: "robot",
            x: svg_x - ROBOT_WIDTH / 2,
            y: svg_y - ROBOT_HEIGHT / 2,
        });

        const robotMain = createSVGElement("rect", {
            id: "robot_main",
            x: 0,
            y: 0,
            width: ROBOT_WIDTH,
            height: ROBOT_HEIGHT,
            rx: 10,
            stroke: GRAY_MAIN,
            fill: GRAY_SUB
        })
        robot.append(robotMain);

        const robotHead = createSVGElement("ellipse", {
            id: "robot_head",
            cx: ROBOT_WIDTH / 2,
            cy: ROBOT_HEIGHT * 0.3,
            rx: 4,
            ry: 4,
            stroke: GRAY_MAIN,
            fill: GRAY_SUB
        })
        robot.append(robotHead);

        svg.append(robot);
    }

    addRobot(0, 0);

    function setRobotPos(x, y) {
        const [svg_x, svg_y] = toSVGPos(x, y);
        const robot = document.getElementById("robot");
        robot.setAttribute("x", svg_x - ROBOT_WIDTH / 2);
        robot.setAttribute("y", svg_y - ROBOT_HEIGHT / 2);
    }

    function drawChart(zones, points) {
        const existingZones = document.getElementById("zones");
        existingZones?.remove()

        const existingPoints = document.getElementById("points");
        existingPoints?.remove();

        const zonesGroup = createSVGElement("g", {
            id: "zones",
        });

        zones.forEach((z) => {
                const zoneSvg = produceZone(z);

                if (zoneSvg !== null) {
                    zonesGroup.append(zoneSvg);
                }
            }
        )

        svg.append(zonesGroup);

        const pointsGroup = createSVGElement("g", {
            id: "points",
        });

        points.forEach((p) => {
                const pointSvg = producePoint(p);

                if (pointSvg !== null) {
                    pointsGroup.append(pointSvg);
                }
            }
        )

        svg.append(pointsGroup);
    }

    function produceZone(zone) {
        if (zone.id === "passage") {
            const p0 = toSVGPos(zone.p0[0], zone.p0[1]);
            const p1 = toSVGPos(zone.p1[0], zone.p1[1]);
            const width = p1[0] - p0[0];
            const height = p1[1] - p0[1];
            return createSVGElement("rect", {
                id: "zone_passage",
                x: p0[0],
                y: p0[1],
                width: width,
                height: height,
                rx: 2,
                opacity: "undefined",
                stroke: GRAY_SUB,
                "fill-opacity": "0",
            });
        }
        return null;
    }

    function producePoint(point) {
        if (point.id.includes("seat")) {
            return produceSeat(point);
        }
        else if (point.id.includes("marker")) {
            return produceMarker(point);
        }
    }

    function produceSeat(point) {
        const [x, y] = toSVGPos(point.x, point.y);
        const seatNum = point.id.substring(5);
        const group = createSVGElement("g", {
            id: "seat_" + seatNum
        });

        const border = createSVGElement("rect", {
            x: x - 25,
            y: y - 25,
            width: 50,
            height: 50,
            rx: 6,
            stroke: GRAY_MAIN,
            fill: GRAY_SUB
        });
        group.append(border);

        const text = createSVGElement("text", {
            x: x,
            y: y,
            "dominant-baseline": "middle",
            "text-anchor": "middle",
            fill: GRAY_MAIN,
            "font-size": 30,
        });
        text.textContent = seatNum;
        group.append(text);

        return group;
    }

    function produceMarker(point) {
        const [x, y] = toSVGPos(point.x, point.y);

        const [_, side, num] = point.id.split("_");

        const group = createSVGElement("g", {
            id: "marker_" + side + "_" + num
        });

        const line = createSVGElement("line", {
            x1: x - 10,
            y1: y,
            x2: x + 10,
            y2: y,
            "stroke-width": 2,
            stroke: RED
        })
        group.append(line);

        const bin = (Number(num) >>> 0).toString(2);
        const valueCenter = y > 0 ? y - 10 : y + 10;

        group.append(createSVGElement("rect", {
            x: x - 9,
            y: valueCenter - 9,
            width: 18,
            height: 18,
            stroke: RED,
            "stroke-width": 0.7,
            "stroke-opacity": 0.6,
            fill: "none"
        }));

        if (bin[bin.length - 1] === "1") {
            group.append(createSVGElement("rect", {
                x: x - 8,
                y: valueCenter - 8,
                width: 8,
                height: 8,
                fill: RED
            }));
        }
        console.log(bin, bin[bin.length - 1], bin[bin.length - 2])
        if (bin[bin.length - 2] === "1") {
            group.append(createSVGElement("rect", {
                x: x,
                y: valueCenter - 8,
                width: 8,
                height: 8,
                fill: RED
            }));
        }
        if (bin[bin.length - 3] === "1") {
            group.append(createSVGElement("rect", {
                x: x - 8,
                y: valueCenter,
                width: 8,
                height: 8,
                fill: RED
            }));
        }
        if (bin[bin.length - 4] === "1") {
            group.append(createSVGElement("rect", {
                x: x,
                y: valueCenter,
                width: 8,
                height: 8,
                fill: RED
            }));
        }

        return group;
    }

    function drawPath(points) {
        const existingPath = document.getElementById("robot_path");
        existingPath?.remove()

        const pathGroup = createSVGElement("g", {
            id: "robot_path"
        })

        const pointsSVG = [];
        points.forEach((point) => {
            const [x, y] = toSVGPos(point[0], point[1]);
            pointsSVG.push(`${x},${y}`);
        });

        const path = createSVGElement("polyline", {
            points: pointsSVG.join(" "),
            fill: "none",
            stroke: RED,
            "stroke-opacity": 0.6,
            "stroke-dasharray": "4"
        });
        pathGroup.append(path);

        const start = toSVGPos(points[0][0], points[0][1]);
        const startCircle = createSVGElement("ellipse", {
            cx: start[0],
            cy: start[1],
            rx: 4,
            ry: 4,
            stroke: RED,
            fill: "none"
        });
        pathGroup.append(startCircle);

        const stop = toSVGPos(points[points.length - 1][0], points[points.length - 1][1]);
        const stopCircle = createSVGElement("ellipse", {
            cx: stop[0],
            cy: stop[1],
            rx: 4,
            ry: 4,
            stroke: RED,
            fill: "none"
        });
        pathGroup.append(stopCircle);

        svg.append(pathGroup);
    }

   drawPath([[0, 0], [0, -30], [140, -30], [140, 0]])

</script>

</body>
</html>
